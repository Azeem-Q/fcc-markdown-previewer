'use strict';

var react = require('react');
var marked = require('marked');

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return fn;
}

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);

  privateSet.add(obj);
}

var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'"
};
/** Used to match HTML entities and HTML characters. */

var reEscapedHtml = /&(?:amp|lt|gt|quot|#(?:0+)?39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
var unescape = function unescape() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, function (entity) {
    return htmlUnescapes[entity] || "'";
  }) : string;
};
var joinBase = function joinBase(path, base) {
  if (!base) {
    return path;
  }

  try {
    return new URL(path, base).href;
  } catch (_unused) {
    return path;
  }
};

var ReactParser = /*#__PURE__*/function () {
  function ReactParser(options) {
    _classCallCheck(this, ReactParser);

    _defineProperty(this, "renderer", void 0);

    this.renderer = options.renderer;
  }

  _createClass(ReactParser, [{
    key: "parse",
    value: function parse(tokens) {
      var _this = this;

      return tokens.map(function (token) {
        switch (token.type) {
          case 'space':
            {
              return null;
            }

          case 'heading':
            {
              return _this.renderer.heading(_this.parseInline(token.tokens), token.depth);
            }

          case 'paragraph':
            {
              return _this.renderer.paragraph(_this.parseInline(token.tokens));
            }

          case 'text':
            {
              return token.tokens ? _this.parseInline(token.tokens) : token.text;
            }

          case 'blockquote':
            {
              var quote = _this.parse(token.tokens);

              return _this.renderer.blockquote(quote);
            }

          case 'list':
            {
              var children = token.items.map(function (item) {
                var listItemChildren = [];

                if (item.task) {
                  var _item$checked;

                  listItemChildren.push(_this.renderer.checkbox((_item$checked = item.checked) !== null && _item$checked !== void 0 ? _item$checked : false));
                }

                listItemChildren.push(_this.parse(item.tokens));
                return _this.renderer.listItem(listItemChildren);
              });
              return _this.renderer.list(children, token.ordered);
            }

          case 'code':
            {
              return _this.renderer.code(token.text, token.lang);
            }

          case 'html':
            {
              return _this.renderer.html(token.text);
            }

          case 'table':
            {
              var headerCells = token.header.map(function (cell, index) {
                return _this.renderer.tableCell(_this.parseInline(cell.tokens), {
                  header: true,
                  align: token.align[index]
                });
              });

              var headerRow = _this.renderer.tableRow(headerCells);

              var header = _this.renderer.tableHeader(headerRow);

              var bodyChilren = token.rows.map(function (row, index) {
                var rowChildren = row.map(function (cell) {
                  return _this.renderer.tableCell(_this.parseInline(cell.tokens), {
                    header: false,
                    align: token.align[index]
                  });
                });
                return _this.renderer.tableRow(rowChildren);
              });

              var body = _this.renderer.tableBody(bodyChilren);

              return _this.renderer.table([header, body]);
            }

          case 'hr':
            {
              return _this.renderer.hr();
            }

          default:
            {
              console.warn("Token with \"".concat(token.type, "\" type was not found")); // eslint-disable-line no-console

              return null;
            }
        }
      });
    }
  }, {
    key: "parseInline",
    value: function parseInline(tokens) {
      var _this2 = this;

      return tokens.map(function (token) {
        switch (token.type) {
          case 'text':
            {
              return _this2.renderer.text(unescape(token.text));
            }

          case 'strong':
            {
              return _this2.renderer.strong(_this2.parseInline(token.tokens));
            }

          case 'em':
            {
              return _this2.renderer.em(_this2.parseInline(token.tokens));
            }

          case 'del':
            {
              return _this2.renderer.del(_this2.parseInline(token.tokens));
            }

          case 'codespan':
            {
              return _this2.renderer.codespan(unescape(token.text));
            }

          case 'link':
            {
              return _this2.renderer.link(token.href, _this2.parseInline(token.tokens));
            }

          case 'image':
            {
              return _this2.renderer.image(token.href, token.text, token.title);
            }

          case 'html':
            {
              return _this2.renderer.html(token.text);
            }

          case 'br':
            {
              return _this2.renderer.br();
            }

          case 'escape':
            {
              return _this2.renderer.text(token.text);
            }

          default:
            {
              console.warn("Token with \"".concat(token.type, "\" type was not found")); // eslint-disable-line no-console

              return null;
            }
        }
      });
    }
  }]);

  return ReactParser;
}();

var _h = /*#__PURE__*/new WeakSet();

var ReactRenderer = /*#__PURE__*/function () {
  function ReactRenderer(options) {
    var _this = this;

    _classCallCheck(this, ReactRenderer);

    _classPrivateMethodInitSpec(this, _h);

    _defineProperty(this, "elementId", 0);

    _defineProperty(this, "options", void 0);

    var renderer = options.renderer;
    this.options = options;

    if (renderer && _typeof(renderer) === 'object') {
      Object.entries(renderer).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            rendererName = _ref2[0],
            renderFunction = _ref2[1];

        if (!_this[rendererName] || typeof renderFunction !== 'function') {
          return;
        }

        _this[rendererName] = function () {
          _this.elementId += 1;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return renderFunction.call.apply(renderFunction, [_this].concat(args));
        };
      });
    }
  }

  _createClass(ReactRenderer, [{
    key: "heading",
    value: function heading(children, level) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, "h".concat(level), children);
    }
  }, {
    key: "paragraph",
    value: function paragraph(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'p', children);
    }
  }, {
    key: "link",
    value: function link(href, text) {
      var url = joinBase(href, this.options.baseURL);
      var target = this.options.openLinksInNewTab ? '_blank' : null;
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'a', text, {
        href: url,
        target: target
      });
    }
  }, {
    key: "image",
    value: function image(src, alt, title) {
      var url = joinBase(src, this.options.baseURL);
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'img', null, {
        src: url,
        alt: alt,
        title: title
      });
    }
  }, {
    key: "codespan",
    value: function codespan(code) {
      var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var className = lang ? "".concat(this.options.langPrefix).concat(lang) : null;
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'code', code, {
        className: className
      });
    }
  }, {
    key: "code",
    value: function code(_code, lang) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'pre', this.codespan(_code, lang));
    }
  }, {
    key: "blockquote",
    value: function blockquote(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'blockquote', children);
    }
  }, {
    key: "list",
    value: function list(children, ordered) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, ordered ? 'ol' : 'ul', children);
    }
  }, {
    key: "listItem",
    value: function listItem(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'li', children);
    }
  }, {
    key: "checkbox",
    value: function checkbox(checked) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'input', null, {
        type: 'checkbox',
        disabled: true,
        checked: checked
      });
    }
  }, {
    key: "table",
    value: function table(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'table', children);
    }
  }, {
    key: "tableHeader",
    value: function tableHeader(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'thead', children);
    }
  }, {
    key: "tableBody",
    value: function tableBody(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'tbody', children);
    }
  }, {
    key: "tableRow",
    value: function tableRow(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'tr', children);
    }
  }, {
    key: "tableCell",
    value: function tableCell(children, flags) {
      var tag = flags.header ? 'th' : 'td';
      return _classPrivateMethodGet(this, _h, _h2).call(this, tag, children, {
        align: flags.align
      });
    }
  }, {
    key: "strong",
    value: function strong(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'strong', children);
    }
  }, {
    key: "em",
    value: function em(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'em', children);
    }
  }, {
    key: "del",
    value: function del(children) {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'del', children);
    }
  }, {
    key: "text",
    value: function text(_text) {
      return _text;
    }
  }, {
    key: "html",
    value: function html(_html) {
      return _html;
    }
  }, {
    key: "hr",
    value: function hr() {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'hr');
    }
  }, {
    key: "br",
    value: function br() {
      return _classPrivateMethodGet(this, _h, _h2).call(this, 'br');
    }
  }]);

  return ReactRenderer;
}();

function _h2(el) {
  var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var elProps = {
    key: "marked-react-".concat(this.elementId)
  };
  this.elementId += 1;
  return /*#__PURE__*/react.createElement(el, _objectSpread2(_objectSpread2({}, props), elProps), children);
}

var validateComponentProps = function validateComponentProps(props) {
  if (props.value && typeof props.value !== 'string') {
    throw new TypeError("[marked-react]: Expected value to be of type string but got ".concat(_typeof(props.value)));
  }

  if (props.children && typeof props.children !== 'string') {
    throw new TypeError("[marked-react]: Expected children to be of type string but got ".concat(_typeof(props.children)));
  }
};

var Markdown = function Markdown(props) {
  var _ref, _props$value;

  validateComponentProps(props); // lexer options

  var lexerOptions = {
    breaks: props.breaks,
    gfm: props.gfm
  }; // convert input markdown into tokens

  var markdownString = (_ref = (_props$value = props.value) !== null && _props$value !== void 0 ? _props$value : props.children) !== null && _ref !== void 0 ? _ref : '';
  var tokens = props.isInline ? marked.Lexer.lexInline(markdownString, lexerOptions) : marked.Lexer.lex(markdownString, lexerOptions); // parser options

  var parserOptions = {
    renderer: new ReactRenderer({
      renderer: props.renderer,
      baseURL: props.baseURL,
      openLinksInNewTab: props.openLinksInNewTab,
      langPrefix: props.langPrefix
    })
  };
  var parser = new ReactParser(parserOptions);
  var children = props.isInline ? parser.parseInline(tokens) : parser.parse(tokens);
  return /*#__PURE__*/react.createElement(react.Fragment, null, children);
};

Markdown.defaultProps = {
  isInline: false,
  breaks: false,
  gfm: true,
  baseURL: null,
  openLinksInNewTab: true,
  langPrefix: 'language-',
  renderer: null
};

module.exports = Markdown;
//# sourceMappingURL=marked-react.cjs.map
